---
layout: page
title: OData Version 3.0 Core Protocol
date: 2014-02-20 07:50:09.000000000 +08:00
permalink: /documentation/odata-version-3-0/odata-version-3-0-core-protocol/
---
<h5 class="alert alert-success">OData Version 4.0 is the current recommended version of OData. OData V4 has been standardized by OASIS and has many features not included in OData Version 3.0. 
<br><br>
<a href="/documentation/" class="alert-link" title=""><span class="glyphicon glyphicon-arrow-right"></span> Go to OData Version 4.0</a></h5>
<h1 id="overview">1. Overview</h1>
<p>The OData Protocol is an application-level protocol for interacting with data via RESTful web services. The protocol supports the description of data models and the editing and querying of data according to those models. It provides facilities for:</p>
<ul>
<li>Metadata: a machine-readable description of the data model exposed by a particular data provider.</li>
<li>Data: sets of data entities and the relationships between them.</li>
<li>Querying: requesting that the service perform a set of filtering and other transformations to its data, then return the results.</li>
<li>Editing: creating, editing, and deleting data.</li>
<li>Operations: invoking custom logic</li>
<li>Vocabularies: attaching custom semantics</li>
</ul>
<p>The OData Protocol is different from other REST-based web service approaches in that it provides a uniform way to describe both the data and the data model. This improves semantic interoperability between systems and allows an ecosystem to emerge.</p>
<p>Towards that end, the OData Protocol follows these design principles:</p>
<ul>
<li>Prefer mechanisms that work on a variety of data stores. In particular, do not assume a relational data model.</li>
<li>Backwards compatibility is paramount. Clients and services which speak different versions of the OData Protocol should interoperate, supporting everything allowed in lower versions.</li>
<li>Follow REST principles unless there is a good and specific reason not to.</li>
<li>OData should degrade gracefully. It should be easy to build a very basic but compliant OData service, with additional work necessary only to support additional capabilities.</li>
<li>Keep it simple. Address the common cases and provide extensibility where necessary.</li>
</ul>
<h1 id="datamodel">2. Data Model</h1>
<p>This section provides a high-level description of the <em>Entity Data Model (EDM)</em>: the abstract data model that MUST be used to describe the data exposed by an OData service. An <a href="#metadatadocumentrequest">OData Metadata Document</a> is a representation of a service’s data model exposed for client consumption.</p>
<p>The central concepts in the EDM are <em>entities</em>, <em>entity sets</em>, and <em>relationships</em>.</p>
<p><em>Entities</em> are instances of entity types (e.g. <code>Customer</code>, <code>Employee</code>, etc.). <em>Entity types</em> are nominal structured types with a key. Entities consist of named properties and MAY include relationships with other entities. Entity types support single inheritance from other entity types. Entities are the core identity types in a data model.</p>
<p><em>Entity sets</em> are named collections of entities (e.g. <code>Customers</code> is an entity set containing <code>Customer</code> entities). An entity can be a member of at most one entity set. Entity sets provide the primary entry points into the data model.</p>
<p>Entities and entity sets are <em>relatable types</em>.</p>
<p><em>Relationships</em> have a name and are used to navigate from an entity to related entities. Relationships are represented in entity types as <em>navigation properties</em>. Relationships may be addressed directly through a <em>navigation link</em> representing the relationship itself. Each relationship has a cardinality.</p>
<p><em>Complex types</em> are keyless nominal structural types consisting of a set of properties. These are value types that lack identity. Complex types are commonly used as property values in an entity or as parameters to operations.</p>
<p>The <em>entity key</em> of an entity type is formed from a subset of primitive properties (e.g. <code>CustomerId</code>, <code>OrderId,</code>LineId`, etc.) of the entity type. The entity key value uniquely identifies an entity within a collection of entities.</p>
<p>Properties declared as part of the entity type’s definition are called <em>declared properties</em>. Entity types which allow additional undeclared properties are called <em>open entity types</em>. These additional properties are called <em>dynamic properties</em>. A dynamic property MUST NOT have the same name as a declared property.</p>
<p><em>Operations</em> allow the execution of custom logic on parts of a data model. <em>Functions</em> do not allow side effects and are composable. <em>Actions</em> allow side effects and are not composable. Actions and functions are global to the service and MAY be used as members of entities and collections of entities.</p>
<p>Entity sets and operations are grouped in a named <em>entity container</em>. This container represents a service’s model.</p>
<p><em>Structural elements</em> are composed of other model elements. Entity types, complex types, association types, and row types are all structural elements. <em>Row types</em> are unnamed structural elements.</p>
<p>An OData <em>resource</em> is anything in the model that can be addressed (an entity set, entity, property, or operation).</p>
<p>Refer to <a href="https://www.odata.org/documentation/odata-version-3-0/common-schema-definition-language-csdl">OData:CSDL</a> for more information on the OData entity data model.</p>
<h2 id="annotations">2.1 Annotations</h2>
<p>Model and instance elements may be annotated with type annotations or value annotations.</p>
<p><em>Type Annotations</em> are defined in metadata as entity types or complex types, and are generally used to define a common concept, such as a person or a movie.</p>
<p><em>Value Annotations</em> are defined in metadata as individual value terms with a name and a type. Value annotations are typically used to specify an individual fact about an element, such as whether it is read-only.</p>
<p>A set of related type annotation terms or value annotation terms in a common namespace comprises a <em>Vocabulary</em>.</p>
<p>Applied <em>annotations</em> have a <em>term</em> (the namespace-qualified name of the annotation being applied), a <em>target</em> (the model or instance element to which the term is applied), and a <em>value</em>. The value may be a static value, or an expression which may contain a path to one or more properties of an annotated entity.</p>
<h1 id="servicemodel">3. Service Model</h1>
<p>OData allows generic clients to discover the capabilities of services. This is possible because the service is defined in a uniform way, using a comon <a href="#datamodel">data model</a>. The service advertises its concrete data model in a machine-readable form.</p>
<p>An OData service consists of two well-defined, static resources and a set of dynamic resources. The two static resources allow machines to ask a service about its data model. The dynamic resources provide ways to manipulate that model.</p>
<p>The <a href="#metadatadocumentrequest"><em>metadata document</em></a> is a static resource that describes the data model and type system understood by that particular OData service.</p>
<p>Clients can use the metadata document to understand how to query and navigate between the entities in the system.</p>
<p>The second static resource in an OData service is the service document. The <a href="#servicedocumentrequest"><em>service document</em></a> lists all of the top-level entity sets exposed by the service.</p>
<p>The rest of an OData service consists of dynamic resources. The URLs for many of these resources can be computed from the information in the metadata document.</p>
<p>A typical OData interaction proceeds as follows:</p>
<ol>
<li>Client has an intent</li>
<li>Client asks for and parses the metadata document.</li>
<li>Client uses metadata to determine how to form a request for its intent.</li>
<li>Client performs request(s) to interact with data.</li>
<li>Each response provides additional options to the client, in terms of both links and instance metadata.</li>
<li>Client can follow links or combine instance metadata with service metadata to determine new entry points.</li>
</ol>
<p>In this way, the service always remains in control. It defines what is allowed at any moment and how that will be requested.</p>
<p>However, the service can describe those operations in terms of composable chunks. This allows the client wide flexibility in how it composes resources to achieve its intent.</p>
<p>See <a href="#requestingdata">Requesting Data</a> and <a href="#datamodification">Data Modification</a> for details.</p>
<h1 id="notationalconventions">4. Notational Conventions</h1>
<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="http://tools.ietf.org/html/rfc2119">RFC2119</a>, “Key words for use in RFCs to Indicate Requirement Levels”)].</p>
<h2 id="normativereferences">4.1. Normative References</h2>
<p>This document references the following related documents:</p>
<ul>
<li><a href="https://www.odata.org/documentation/odata-version-3-0/common-schema-definition-language-csdl">OData:CSDL</a>. Detailed description of the OData Entity Data Model.</li>
<li><a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a>. Conventions for constructing OData requests.</li>
<li><a href="https://www.odata.org/documentation/odata-version-3-0/abnf">OData:ABNF</a> Full ABNF rules for OData requests.</li>
<li><a href="https://www.odata.org/documentation/odata-version-3-0/atom-format">OData:ATOM</a> ATOM encoding for OData payloads. OData Services MUST support the ATOM encoding.</li>
<li><a href="https://www.odata.org/documentation/odata-version-3-0/json-verbose-format">OData:JSON</a> A JSON encoding for OData payloads. OData services SHOULD support a JSON encoding.</li>
<li><a href="https://www.odata.org/documentation/odata-version-3-0/batch-processing">OData:Batch</a> Support for grouping multiple OData requests in a single batch.</li>
<li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC2616</a> HTTP 1.1 Specification</li>
<li><a href="http://tools.ietf.org/html/rfc5023">RFC5023</a> The Atom Publishing Protocol</li>
<li><a href="http://tools.ietf.org/html/rfc2119">RFC2119</a> Keywords for use in RFCs to Indicate Requirement Levels</li>
<li><a href="http://tools.ietf.org/html/rfc5789">RFC5789</a> Patch Method for HTTP</li>
</ul>
<h2 id="examplepayloads">4.2. Example Payloads</h2>
<p>Some sections of this specification are illustrated with non-normative example OData request and response payloads. However, the text of this specification provides the definition of conformance.</p>
<h2 id="interpretingexamples">4.3. Interpreting Examples</h2>
<p>All code examples in this document are non-normative.</p>
<h1 id="versioning">5. Versioning</h1>
<p>This document defines version 3.0 of the OData Specification.</p>
<p>The OData protocol supports a versioning scheme for enabling services to expose new features and format versions without breaking compatibility with older clients.</p>
<p>OData requests and responses MAY be versioned according to <a href="#thedataserviceversionheader">The <code>DataServiceVersion</code> Header</a>.</p>
<p>An OData client SHOULD use the <a href="#themindataserviceversionrequestheader">MinDataServiceVersion</a> and <a href="#themaxdataserviceversionrequestheader">MaxDataServiceVersion</a> headers in order to specify the range of acceptable response DataServiceVersions.</p>
<p>The service SHOULD respond with the maximum version supported by the service that is less than or equal to the specified <code>MaxDataServiceVersion</code>.</p>
<p><code>DataServiceVersion</code>, <code>MinDataServiceVersion</code>, and <code>MaxDataServiceVersion</code> header fields MUST be of the following form:</p>
<pre><code>majorversionnumber + "." + minorversionnumber 
</code></pre>
<p>This version of the specification defines the following valid data service version values: “1.0”, “2.0”, and “3.0”, corresponding to OData versions 1.0, 2.0, and 3.0, respectively.</p>
<h1 id="extensibility">6. Extensibility</h1>
<p>The OData protocol supports both user- and version-driven extensibility through a combination of versioning, convention, and explicit extension points.</p>
<h2 id="queryoptionextensibility">6.1. Query Option Extensibility</h2>
<p>Query options within the request URL can control how a particular request is processed by the service.</p>
<p>OData-defined system query options are prefixed with “$”. Services MAY support additional query options not defined in the OData specification, but they MUST NOT begin with the “$” character.</p>
<p>OData services SHOULD NOT require any query options to be specified in a request, and SHOULD fail any request that contains query options that it does not understand.</p>
<h2 id="payloadextensibility">6.2. Payload Extensibility</h2>
<p>OData supports extensibility in the payload, according to the specific format.</p>
<p>Regardless of the format, additional content MUST NOT be present if it needs to be understood by the receiver in order to correctly interpret the payload. Thus, clients and services MAY safely ignore any content not specifically defined in the version of the payload specified by the [<code>DataServiceVersion</code>(#thedataserviceversionheader) header.</p>
<h2 id="actionfunctionextensibility">6.3. Action/Function Extensibility</h2>
<p>Actions and functions extend the set of operations that can be performed on or with a service or resource. Actions MAY have side-effects. For example actions may be used to extend CUD operations or to invoke custom operations. Functions MUST NOT have side-effects. Functions can be invoked:</p>
<ul>
<li>directly from the service root</li>
<li>from an url that addresses a resource</li>
<li>inside a predicate to a <code>$filter</code> or <code>$orderby</code> system query option.</li>
</ul>
<p>Fully qualified action and function names include a namespace prefix. The <code>odata</code> and <code>geo</code> namespaces are reserved for the use of this specification.</p>
<p>An OData service MUST fail any request that contains actions or functions that it does not understand.</p>
<h2 id="vocabularyextensibility">6.4. Vocabulary Extensibility</h2>
<p>Vocabularies provide the ability to annotate metadata as well as instance data, and define a powerful extensibility point for OData.</p>
<p>Metadata annotations can be used to define additional characteristics or capabilities of a metadata element, such as a service, entity type, property, function, action or parameter. For example, a metadata annotation may define ranges of valid values for a particular property.</p>
<p>Instance annotations can be used to define additional information associated with a particular result, entity, property, or error; for example whether a property is read-only for a particular instance.</p>
<p>Annotations that apply across instances SHOULD be specified within the metadata. Where the same annotation is defined at both the metadata and instance level, the instance-level annotation SHOULD override the annotation specified at the metadata level.</p>
<p>A service SHOULD NOT require a client to interpret annotations it uses.</p>
<h2 id="headerfieldextensibility">6.5. Header Field Extensibility</h2>
<p>OData defines semantics around certain HTTP request and response headers. Services that support a version of OData MUST understand and comply with the headers defined by that version. Compliance means either honoring the semantics of the header field or failing the request.</p>
<p>Individual services MAY define custom headers. These headers MUST NOT begin with <code>OData-</code>. Custom headers SHOULD be optional when making requests to the service. A service MUST NOT require a client to understand custom headers to accurately interpret the response.</p>
<h2 id="formatextensibility">6.6. Format Extensibility</h2>
<p>An OData Service MUST support at least the <a href="https://www.odata.org/documentation/odata-version-3-0/atom-format">OData:Atom</a> format, and MAY support additional formats for both request and response bodies.</p>
<h1 id="formats">7. Formats</h1>
<p>The client may request a particular response format through the <code>Accept</code> header, as specified in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC2616</a>, or through the <a href="#theformatsystemqueryoption"><code>$format</code> System Query Option</a>.</p>
<p>In the case that both the <code>Accept</code> header and the <code>$format</code> query option are specified on a request, the value specified in the <code>$format</code> query option SHOULD be used.</p>
<p>If the service does not support the requested format, it SHOULD reply with a <code>406 Not Acceptable</code> error response.</p>
<p>See the format-specific specifications (<a href="https://www.odata.org/documentation/odata-version-3-0/json-verbose-format">OData:JSON</a>, <a href="https://www.odata.org/documentation/odata-version-3-0/atom-format">OData:Atom</a>) for details.</p>
<h1 id="headerfields">8. Header Fields</h1>
<p>OData defines semantics around the following request and response headers. Additional headers MAY be specified, but have no unique semantics defined in OData.</p>
<h2 id="commonheaders">8.1. Common Headers</h2>
<p>The <a href="#thedataserviceversionheader"><code>DataServiceVersion</code></a> and <a href="#thecontent-typeheader"><code>Content-Type</code></a> headers may be used on any OData request or response.</p>
<h3 id="thedataserviceversionheader">8.1.1. The <code>DataServiceVersion</code> Header</h3>
<p>OData clients MAY use the <code>DataServiceVersion</code> header on a request to specify the version of the protocol used to generate the request.</p>
<p>If present on a request, the service MUST interpret the request according to the rules defined in the specified version of the protocol, or fail the request with a 4xx response code.</p>
<p>If not specified, the service MUST assume the request is generated using the maximum version of the protocol that the service understands.</p>
<p>OData services SHOULD specify the <code>DataServiceVersion</code> header on a response to specify the version of the protocol used to generate the response. If present on a response, the client MUST interpret the response according to the rules defined in the specified version of the protocol. If not specified, the client MUST assume the request is generated using version 1.0 of the OData Protocol.</p>
<p>For more details see <a href="#versioning">Versioning</a>.</p>
<h3 id="thecontent-typeheader">8.1.2. The <code>Content-Type</code> Header</h3>
<p>The format of an individual request or response body MUST be specified in the <code>Content-Type</code> header of the request or response.</p>
<p>See the format-specific specifications (<a href="https://www.odata.org/documentation/odata-version-3-0/json-verbose-format">OData:JSON</a>, <a href="https://www.odata.org/documentation/odata-version-3-0/atom-format">OData:Atom</a>) for details.</p>
<h2 id="commonrequestheaders">8.2. Common Request Headers</h2>
<p>In addition to the <a href="#commonheaders">Common Headers</a>, a client MAY specify any combination of the following request headers.</p>
<h3 id="themaxdataserviceversionrequestheader">8.2.1. The <code>MaxDataServiceVersion</code> Request Header</h3>
<p>Clients SHOULD specify a <code>MaxDataServiceVersion</code> request header.</p>
<p>If specified, the service MUST generate a response with a <a href="#thedataserviceversionheader"><code>DataServiceVersion</code></a> less than or equal to the specified <code>MaxDataServiceVersion</code>.</p>
<p>If <code>MaxDataServiceVersion</code> is not specified, then the service SHOULD interpret the request as having a <code>MaxDataServiceVersion</code> equal to the maximum version supported by the service.</p>
<p>For more details see <a href="#versioning">Versioning</a>.</p>
<h3 id="themindataserviceversionrequestheader">8.2.2. The <code>MinDataServiceVersion</code> Request Header</h3>
<p>Clients SHOULD specify a <code>MinDataServiceVersion</code> request header.</p>
<p>If specified, the service MUST generate a response with a <a href="#thedataserviceversionheader">DataServiceVersion</a> greater than or equal to the specified <code>MinDataServiceVersion</code>.</p>
<p>The service SHOULD respond with the maximum version supported by the service that is less than or equal to the specified <code>MaxDataServiceVersion</code>.</p>
<p>For more details see <a href="#versioning">Versioning</a>.</p>
<h3 id="theacceptrequestheader">8.2.3. The <code>Accept</code> Request Header</h3>
<p>As specified in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC2616</a>, the client MAY specify the set of accepted <a href="#formats">formats</a> through the use of the <code>Accept</code> Header.</p>
<h3 id="theif-matchrequestheader">8.2.4. The <code>If-Match</code> Request Header</h3>
<p>A client MAY include an <code>If-Match</code> header in a request to GET, PUT, MERGE, PATCH or DELETE an entity or entity property, or to invoke an action bound to an entity. The value of the <code>If-Match</code> request header MUST be an ETag value previously retrieved for the entity.</p>
<p>If specified, the request MUST only be invoked if the specified value matches the current ETag value of the entity. If the value does not match the current ETag value of the entity for a <a href="#datamodification">Data Modification</a> or <a href="#actions">Action</a> request, the service MUST respond with ‘412 Precondition Failed’ and MUST ensure that no data is modified as a result of the request.</p>
<h3 id="theif-none-matchrequestheader">8.2.5. The <code>If-None-Match</code> Request Header</h3>
<p>A client MAY include an <code>If-None-Match</code> header in a request to GET, PUT, MERGE, PATCH or DELETE an entity or entity property, or to invoke an action bound to an entity. The value of the <code>If-None-Match</code> request header MUST be an ETag value previously retrieved for the entity.</p>
<p>If specified, the request MUST only be invoked if the specified value does not match the current ETag value of the entity. If the value does match the current ETag value of the entity for a <a href="#datamodification">Data Modification</a> or <a href="#actions">Action</a> request, the service MUST respond with ‘412 Precondition Failed’ and MUST ensure that no data is modified as a result of the request.</p>
<h2 id="commonresponseheaders">8.3. Common Response Headers</h2>
<p>In addition to the <a href="#commonheaders">Common Headers</a>, a service MAY specify the following response headers.</p>
<h3 id="theetagheader">8.3.1. The <code>ETag</code> Header</h3>
<p>A request that returns an individual entity MAY include an <code>ETag</code> header.</p>
<p>The value specified in the <code>ETag</code> header may be specified in the <a href="#theif-matchrequestheader"><code>If-Match</code></a> or <a href="#theif-none-matchrequestheader"><code>If-None-Match</code></a> header of a subsequent <a href="#datamodification">Data Modification</a> or <a href="#actions">Action</a> request in order to apply optimistic concurrency in updating, deleting, or invoking the action bound to, the entity.</p>
<h3 id="thelocationheader">8.3.2. The <code>Location</code> Header</h3>
<p>The Location header is used to specify the URL of an entity modified through a <a href="#datamodification">Data Modification</a> request, or the request URL to check on the status of an asynchronous operation as described in <a href="#acceptedresponsecode"><code>202 Accepted</code></a>.</p>
<h2 id="datamodificationrequestheaders">8.4. Data Modification Request Headers</h2>
<p>In addition to the <a href="#commonheaders">Common Headers</a>, a client MAY specify the following headers on a <a href="#datamodification">Data Modification</a> request.</p>
<h3 id="thepreferheader">8.4.1. The <code>Prefer</code> Header</h3>
<p>The client MAY specify a <code>Prefer</code> header on <a href="#datamodification">Data Modification</a> or <a href="#actions">Action</a> request.</p>
<p>A Prefer header with a value of <code>return-no-content</code> requests that the service invoke the request but not return content in the response. The service MAY honor this request by returning <a href="#nocontentresponsecode"><code>204 No Content</code></a>.</p>
<p>A Prefer header with a value of <code>return-content</code> requests that the service invoke the request and return the modified entity. The service MAY honor this request by returning the successfully modified entity in the body of the response, formatted according to the rules specified for the requested <a href="#formats">format</a>.</p>
<p>In response to a request containing a <code>Prefer</code> header, the service MAY return the <a href="#thepreference-appliedheader"><code>Preference-Applied</code></a> Header.</p>
<h2 id="datamodificationresponseheaders">8.5. Data Modification Response Headers</h2>
<p>In addition to the <a href="#commonheaders">Common Headers</a>, a service MAY specify the following headers on a <a href="#datamodification">Data Modification</a> response.</p>
<h3 id="thedataserviceidheader">8.5.1. The <code>DataServiceId</code> Header</h3>
<p>A response to a PUT, POST, MERGE, or PATCH request that returns <code>404 No Content</code> MUST include a DataServiceId response header. The value of the header is the URI identifier of the entity that was acted on by the request.</p>
<h3 id="thepreference-appliedheader">8.5.2. The <code>Preference-Applied</code> Header</h3>
<p>In response to a <a href="#datamodification">Data Modification</a> or <a href="#actions">Action</a> request containing a <a href="#thepreferheader"><code>Prefer header</code></a>, the service may include a <code>Preference-Applied</code> response header to specify the <code>prefer</code> header value that was honored.</p>
<p>If the service has returned content in response to a request including a <code>Prefer</code> header with a value of <code>return-content</code>, it MAY include a <code>Preference-Applied</code> response header with a value of <code>return-content</code>.</p>
<p>If the service has returned content in response to a request including a <code>Prefer</code> header with a value of <code>return-content</code>, it MAY include a <code>Preference-Applied</code> response header with a value of <code>return-no-content</code>.</p>
<h3 id="theretry-afterheader">8.5.3. The <code>Retry-After</code> Header</h3>
<p>A service MUST include a <code>Retry-After</code> header in a <a href="#acceptedresponsecode"><code>202 Accepted</code></a> response.</p>
<p>The Retry-After header specifies the suggested length of time, in seconds, after which the client SHOULD use the URL returned in the <a href="#thelocationheader"><code>Location Header</code></a> to check on the status of the operation.</p>
<h1 id="commonresponsesemantics">9. Common Response Semantics</h1>
<p>An OData service MAY respond to any request using any valid HTTP status code appropriate for the request. A service SHOULD be as specific as possible in its choice of HTTP status codes.</p>
<p>The following represent the most common success response codes. In some cases, a service MAY respond with a more specific success code.</p>
<h2 id="successresponsecodes">9.1. Success Response Codes</h2>
<p>The following response codes represent successful requests.</p>
<h3 id="okresponsecode">9.1.1. <code>200 OK</code> Response Code</h3>
<p>A GET, PUT, MERGE, or PATCH request MAY return <code>200 OK</code> if the operation is completed successfully. In this case, the response body MUST contain the value of the entity or property specified in the request URL.</p>
<h3 id="createdresponsecode">9.1.2. <code>201 Created</code> Response Code</h3>
<p>A POST request MAY return <code>201 Created</code> if the entity or link was successfully created. In this case, the response body MUST contain the updated entity.</p>
<h3 id="acceptedresponsecode">9.1.3. <code>202 Accepted</code> Response Code</h3>
<p>A service MAY reply to a Data Modification Request with <code>202 Accepted</code>, indicating that the request has been accepted but has not yet completed. In this case, the response body MUST contain a <a href="#thelocationheader"><code>Location</code> header</a> in addition to a <a href="#theretry-afterheader"><code>Retry-After</code> header</a>, and the response body MUST be empty.</p>
<p>Once the request has successfully completed, the service MUST return <code>303 See Other</code> with a <a href="#thelocationheader"><code>Location</code> header</a> specifying the final URL to retrieve the outcome of the operation. The response body and headers from this final URL MUST be formatted as would the completion of the initial Data Modification Request.</p>
<h3 id="nocontentresponsecode">9.1.4. <code>204 No Content</code> Response Code</h3>
<p>A service may reply to a Data Modification Request with <code>204 No Content</code>. In this case, the response body MUST be empty.</p>
<h3 id="xxredirectresponsecode">9.1.5. <code>3xx Redirect</code> Response Code</h3>
<p>As per <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC2616</a>, an OData service MAY respond to any Data Modification request with a response code of <code>3xx Redirection</code>. In this case, the response SHOULD include a <a href="#thelocationheader"><code>Location</code> header</a> with the URL from which the result can be obtained.</p>
<p>The service MUST ensure that no observable change has occurred to the state of the service as a result of any request that returns a <code>3xx</code>.</p>
<h2 id="xxclienterrorresponses">9.2. <code>4xx Client Error</code> Responses</h2>
<p>Services SHOULD return <code>4xx Client Error</code> in response to client errors such as malformed requests, in addition to requests for non-existent resources such as entity collections, entities, or properties.</p>
<p>The service MUST ensure that no observable change has occurred to the state of the service as a result of any request that returns an error status code.</p>
<p>In the case that a response body is defined for the error code, the body of the error is as defined for the appropriate <a href="#formats">format</a>.</p>
<h3 id="notfoundresponsecode">9.2.1. <code>404 Not Found</code> Response Code</h3>
<p>If the entity or collection specified by the request URL does not exist, the service SHOULD respond with <code>404 Not Found</code> and an empty response body.</p>
<h3 id="instreamerrors">9.3 InStream Errors</h3>
<p>In the case that the service encounters an error after sending a success status to the client, the service MUST generate an in-stream error which SHOULD leave the response malformed. Clients MUST assume that any malformed responses are invalid and results SHOULD be discarded.</p>
<p>This specification does not prescribe a particular format for such instream errors.</p>
<h1 id="odataservicerequests">10. OData Service Requests</h1>
<p>An OData Service MAY support the following types of requests.</p>
<h2 id="metadatarequests">10.1. Metadata Requests</h2>
<p>An OData service is a self-describing service that exposes metadata defining the entity sets, relationships, entity types, and operations.</p>
<h3 id="servicedocumentrequest">10.1.1. Service Document Request</h3>
<p>To request a <code>Service Document</code> describing the set of entity collections (i.e., entity sets) that can be queried from a service, the client issues a GET request to the root URL of the service (the <em>Service Root</em>).</p>
<p>The format of the Service Document is dependent upon the format selected. For example, in Atom the Service Document is an AtomPub Service Document (as specified in <a href="http://tools.ietf.org/html/rfc5023">RFC5023</a>).</p>
<h3 id="metadatadocumentrequest">10.1.2. Metadata Document Request</h3>
<p>An OData <em>Metadata Document</em> is a representation of the <a href="#DataModel">data model</a> that describes the data and operations exposed by an OData service.</p>
<p><a href="https://www.odata.org/documentation/odata-version-3-0/common-schema-definition-language-csdl">OData:CSDL</a> describes an XML representation for OData Metadata Documents and provides an XSD to validate their contents. The media type of the XML representation of an OData Metadata Document is ‘application/xml’.</p>
<p>OData services MUST expose a Metadata Document which defines all data exposed by the service. The <em>Metadata Document URL</em> SHOULD be the root URL of the service with “/$metadata” appended. To retrieve this document a client issues a GET request to the Metadata Document URL.</p>
<p>If a request for metadata does not specify a format preference (via <a href="#theacceptrequestheader"><code>Accept</code></a> header or <a href="#theformatsystemqueryoption">$format</a>) then the XML representation MUST be returned.</p>
<h2 id="requestingdata">10.2. Requesting Data</h2>
<p>OData services support requesting data through the use of HTTP GET requests.</p>
<p>The path of the URL specifies the target of the request (for example; the collection of entities, entity, navigation property, scalar property, or operation). Additional query operators, such as filter, sort, page, and projection operations are specified through query options.</p>
<p>The format of the returned data is dependent upon the request and the format specified by the client, either in the <a href="#theacceptrequestheader"><code>Accept</code></a> header or using the <a href="#theformatsystemqueryoption">$format</a> query option.</p>
<p>This section describes the types of data requests defined by OData. For complete details on the syntax for building requests, see <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a>.</p>
<h3 id="requestingindividualentities">10.2.1. Requesting Individual Entities</h3>
<p>To retrieve an individual entity, a client makes a GET request to an <em>entity request URL</em>.</p>
<p>The entity request URL MAY be returned in a response payload containing that instance (for example, as a self-link in an <a href="https://www.odata.org/documentation/odata-version-3-0/atom-format">Atom Payload</a>).</p>
<p>Services MAY support conventions for constructing an entity request URL using the entity’s Key Value(s), as described in <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a>.</p>
<h3 id="requestingindividualproperties">10.2.2. Requesting Individual Properties</h3>
<p>A service SHOULD support retrieving an individual property value.</p>
<p>To retrieve an individual property, a client issues a GET request to the property URL. The property URL is the entity request URL with “<code>/</code>” and the property name appended.</p>
<p>For complex typed properties, the path MAY be further extended with the name of the individual property of the complex type.</p>
<p>See <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a> for details.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products(1)/Name
</code></pre>
<h4 id="requestingapropertysrawvalueusingvalue">10.2.2.1. Requesting a Property’s Raw Value using <code>$value</code></h4>
<p>A service SHOULD support retrieving the raw value of a primitive type property. To retrieve this value, a client sends a GET request to the property value URL. See the <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a> document for details.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products(1)/Name/$value
</code></pre>
<p>The raw value of an Edm.Binary property MUST be serialized as an unencoded byte stream.</p>
<p>The raw value of other properties SHOULD be represented using the <code>text/plain</code> media type. See <a href="https://www.odata.org/documentation/odata-version-3-0/abnf">OData:ABNF</a> for details.</p>
<p>A <code>$value</code> request for a property that is <code>NULL</code> SHOULD result in a <code>404 Not Found</code>. response.</p>
<h3 id="queryingcollections">10.2.3. Querying Collections</h3>
<p>OData services support querying collections of entities.</p>
<p>The target collection is specified through a URL, and query operations such as filter, sort, paging, and projection are specified as <em>System Query Options</em> provided as query options. The names of all System Query Options are prefixed with a “$” character.</p>
<p>An OData service MAY support some or all of the System Query Options defined. If a data service does not support a System Query Option, it MUST fail any request that contains the unsupported option.</p>
<h4 id="thefiltersystemqueryoption">10.2.3.1. The <code>$filter</code> System Query Option</h4>
<p>The set of entities returned MAY be restricted through the use of the <code>$filter</code> System Query Option.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$filter=Price lt 10.00
</code></pre>
<p>Returns all Products whose Price is less than $10.00.</p>
<p>The value of the <code>$filter</code> option is a boolean expression as defined in <a href="https://www.odata.org/documentation/odata-version-3-0/abnf">OData:ABNF</a>.</p>
<h5 id="built-infilteroperations">10.2.3.1.1. Built-in Filter Operations</h5>
<p>OData supports a set of built-in filter operations, as described in this section. For a full description of the syntax used when building requests, see <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a>.</p>
<p>l</p>
<table border="1">
<tbody>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td colspan="3"><strong>Logical Operators</strong></td>
</tr>
<tr>
<td>eq</td>
<td>Equal</td>
<td>/Suppliers?$filter=Address/City eq 'Redmond'</td>
</tr>
<tr>
<td>ne</td>
<td>Not equal</td>
<td>/Suppliers?$filter=Address/City ne 'London'</td>
</tr>
<tr>
<td>gt</td>
<td>Greater than</td>
<td>/Products?$filter=Price gt 20</td>
</tr>
<tr>
<td>ge</td>
<td>Greater than or equal</td>
<td>/Products?$filter=Price ge 10</td>
</tr>
<tr>
<td>lt</td>
<td>Less than</td>
<td>/Products?$filter=Price lt 20</td>
</tr>
<tr>
<td>le</td>
<td>Less than or equal</td>
<td>/Products?$filter=Price le 100</td>
</tr>
<tr>
<td>and</td>
<td>Logical and</td>
<td>/Products?$filter=Price le 200 and Price gt 3.5</td>
</tr>
<tr>
<td>or</td>
<td>Logical or</td>
<td>/Products?$filter=Price le 3.5 or Price gt 200</td>
</tr>
<tr>
<td>not</td>
<td>Logical negation</td>
<td>/Products?$filter=not endswith(Description,'milk')</td>
</tr>
<tr>
<td colspan="3"><strong>Arithmetic Operators</strong></td>
</tr>
<tr>
<td>add</td>
<td>Addition</td>
<td>/Products?$filter=Price add 5 gt 10</td>
</tr>
<tr>
<td>sub</td>
<td>Subtraction</td>
<td>/Products?$filter=Price sub 5 gt 10</td>
</tr>
<tr>
<td>mul</td>
<td>Multiplication</td>
<td>/Products?$filter=Price mul 2 gt 2000</td>
</tr>
<tr>
<td>div</td>
<td>Division</td>
<td>/Products?$filter=Price div 2 gt 4</td>
</tr>
<tr>
<td>mod</td>
<td>Modulo</td>
<td>/Products?$filter=Price mod 2 eq 0</td>
</tr>
<tr>
<td colspan="3"><strong>Grouping Operators</strong></td>
</tr>
<tr>
<td>( )</td>
<td>Precedence grouping</td>
<td>/Products?$filter=(Price sub 5) gt 10</td>
</tr>
</tbody>
</table>
<h5 id="built-inqueryfunctions">10.2.3.1.2. Built-in Query Functions</h5>
<p>OData supports a set of built-in functions that can be used within <code>$filter</code> operations. The following table lists the available functions. For a full description of the syntax used when building requests, see <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a>.</p>
<p>OData does note define an ISNULL or COALESCE operator. Instead, there is a <code>null</code> literal which can be used in comparisons.</p>
<table border="1">
<tbody>
<tr>
<th>Function</th>
<th>Example</th>
</tr>
<tr>
<td colspan="3"><strong>String Functions</strong></td>
</tr>
<tr>
<td>bool substringof(string searchString, string searchInString)</td>
<td>substringof('Alfreds',CompanyName)</td>
</tr>
<tr>
<td>bool endswith(string string, string suffixString)</td>
<td>endswith(CompanyName,'Futterkiste')</td>
</tr>
<tr>
<td>bool startswith(string string, string prefixString)</td>
<td>startswith(CompanyName,'Alfr')</td>
</tr>
<tr>
<td>int length(string string)</td>
<td>length(CompanyName) eq 19</td>
</tr>
<tr>
<td>int indexof(string searchInString, string searchString)</td>
<td>indexof(CompanyName,'lfreds') eq 1</td>
</tr>
<tr>
<td>string replace(string searchInString, string searchString, string replaceString)</td>
<td>replace(CompanyName,' ', '') eq 'AlfredsFutterkiste'</td>
</tr>
<tr>
<td>string substring(string string, int pos)</td>
<td>substring(CompanyName,1) eq 'lfreds Futterkiste'</td>
</tr>
<tr>
<td>string substring(string string, int pos, int length)</td>
<td>substring(CompanyName,1, 2) eq 'lf'</td>
</tr>
<tr>
<td>string tolower(string string)</td>
<td>tolower(CompanyName) eq 'alfreds futterkiste'</td>
</tr>
<tr>
<td>string toupper(string string)</td>
<td>toupper(CompanyName) eq 'ALFREDS FUTTERKISTE'</td>
</tr>
<tr>
<td>string trim(string string)</td>
<td>trim(CompanyName) eq 'Alfreds Futterkiste'</td>
</tr>
<tr>
<td>string concat(string string1, string string2)</td>
<td>concat(concat(City,', '), Country) eq 'Berlin, Germany'</td>
</tr>
<tr>
<td colspan="3"><strong>Date Functions</strong></td>
</tr>
<tr>
<td>int day(DateTime datetimeValue)</td>
<td>day(BirthDate) eq 8</td>
</tr>
<tr>
<td>int hour(DateTime datetimeValue)</td>
<td>hour(BirthDate) eq 1</td>
</tr>
<tr>
<td>int minute(DateTime datetimeValue)</td>
<td>minute(BirthDate) eq 0</td>
</tr>
<tr>
<td>int month(DateTime datetimeValue)</td>
<td>month(BirthDate) eq 12</td>
</tr>
<tr>
<td>int second(DateTime datetimeValue)</td>
<td>second(BirthDate) eq 0</td>
</tr>
<tr>
<td>int year(DateTime datetimeValue)</td>
<td>year(BirthDate) eq 1948</td>
</tr>
<tr>
<td colspan="3"><strong>Math Functions</strong></td>
</tr>
<tr>
<td>double round(double doubleValue)</td>
<td>round(Freight) eq 32</td>
</tr>
<tr>
<td>decimal round(decimal decimalValue)</td>
<td>round(Freight) eq 32</td>
</tr>
<tr>
<td>double floor(double doubleValue)</td>
<td>floor(Freight) eq 32</td>
</tr>
<tr>
<td>decimal floor(decimal datetimeValue)</td>
<td>floor(Freight) eq 32</td>
</tr>
<tr>
<td>double ceiling(double doubleValue)</td>
<td>ceiling(Freight) eq 33</td>
</tr>
<tr>
<td>decimal ceiling(decimal datetimeValue)</td>
<td>ceiling(Freight) eq 33</td>
</tr>
<tr>
<td colspan="3"><strong>Type Functions</strong></td>
</tr>
<tr>
<td>bool IsOf(type value)</td>
<td>isof('NorthwindModel.Order')</td>
</tr>
<tr>
<td>bool IsOf(expression value, type targetType)</td>
<td>isof(ShipCountry,'Edm.String')</td>
</tr>
</tbody>
</table>
<h5 id="theexpandsystemqueryoption">10.2.3.1.3 The <code>$expand</code> System Query Option</h5>
<p>The presence of the <code>$expand</code> system query option indicates that entities related to the entity, or collection of entities, identified by the resource path section of the URL MUST be represented inline.</p>
<p>The value of the <code>$expand</code> query option MUST be a comma separated list of navigation property paths.</p>
<p>The service MUST include any actions or functions that are bound to the associated entities that are introduced via <code>$expand</code>, unless a <code>$select</code> System Query Option is also included in the request and that <code>$select</code> requests that the actions/functions be omitted.</p>
<p>For a full description of the syntax used when building requests, see <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a>.</p>
<p>Examples</p>
<pre><code>http://host/service.svc/Customers?$expand=Orders
</code></pre>
<p>For each customer entity within the Customers entity set, the value of all associated Orders MUST be represented inline.</p>
<pre><code>http://host/service.svc/Orders?$expand=OrderLines/Product,Customer
</code></pre>
<p>For each Order within the Orders entity set, the following MUST be represented inline:</p>
<ul>
<li>The Order lines associated to the Orders identified by the resource path section of the URL and the products associated to each Order line.</li>
<li>The customer associated with each Order returned.http://host/service.svc/Customers?$expand=SampleModel.VipCustomer/InHouseStaff</li>
</ul>
<p>For each Customer entity in the Customers entity set, the value of all associated InHouseStaff MUST be represented inline if the entity is of type VipCustomer or a subtype of that. For entities that are not of type VipCustomer, or any of its subtypes, that entity SHOULD be returned with no inline representation for the expanded navigation property.</p>
<h4 id="theselectsystemqueryoption">10.2.3.2 The <code>$select</code> System Query Option</h4>
<p>The <code>$select</code> system query option requests that the service return only the properties, open properties, related properties, actions and functions explicitly requested by the client. The service MUST return the specified content, and MAY choose to return additional information.</p>
<p>The value of the $select query option is a comma separated list of property paths, qualified action names, qualified function names, or the star operator (*), or the star operator prefixed with the name of the entity container in order to specify all operations within the container.</p>
<p>For example, the following request returns just the Rating and ReleaseDate for the matching Products:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$select=Rating,ReleaseDate
</code></pre>
<p>It is also possible to request all properties, using a star request:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$select=*
</code></pre>
<p>A star request SHOULD NOT introduce actions or functions not otherwise requested.</p>
<p>Properties of related entities MAY be specified by providing a property path in the select list. In order to select properties from related entities, the appropriate navigation property MUST be specified through the <code>$expand</code> query option:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$select=*,Category/Name&amp;$expand=Category
</code></pre>
<p>It is also possible to request all actions and functions available for each returned entity:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$select=DemoService.*
</code></pre>
<p>For AtomPub formatted responses, the value of a <code>$select</code> clause applies only to the properties returned within the <code>m:properties</code> element. For example, if a property of an entity type is mapped to an Atom element, then that property MUST always be included in the response according to its customizable feed mapping.</p>
<h4 id="theorderbysystemqueryoption">10.2.3.3 The <code>$orderby</code> System Query Option</h4>
<p>The <code>$orderby</code> System Query option specifies the order in which entities are returned from the service.</p>
<p>The value of the <code>$orderby</code> System Query option contains a comma separated list of property navigation paths to sort by, where each property navigation path terminates on a primitive property.</p>
<p>A type cast using the qualified entity type name is required to order by a property defined on a derived type.</p>
<p>The property name MAY include the suffix “asc” for ascending or “desc” for descending, separated from the property name by one or more spaces. If “asc” or “desc” is not specified, the service MUST order by the specified property in ascending order.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$orderby=ReleaseDate asc, Rating desc
</code></pre>
<h4 id="thetopsystemqueryoption">10.2.3.4. The <code>$top</code> System Query Option</h4>
<p>The <code>$top</code> System Query Option specifies that only the first n records SHOULD be returned, where n is a non-negative integer value specified by the <code>$top</code> query option.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$top=5
</code></pre>
<p>Would return only the first five Products in the Products entity set.</p>
<p>If no unique ordering is imposed through an <a href="#theorderbysystemqueryoption"><code>$orderby</code></a> query option, the service MUST impose a stable ordering across requests that include <code>$top</code>.</p>
<h4 id="theskipsystemqueryoption">10.2.3.5. The <code>$skip</code> System Query Option</h4>
<p>The <code>$skip</code> System Query Option specifies that the result MUST NOT include the first n entities, where n is a non-negative integer value specified by the <code>$skip</code> query option.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$skip=5
</code></pre>
<p>Would return Products starting with the 6th Product in the Products entity set.</p>
<p>Where [<code>$top</code>](thetopsystemqueryoption] and <code>$skip</code> are used together, the <code>$skip</code> MUST be applied before the <code>$top</code>, regardless of the order in which they appear in the request.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$top=5&amp;$skip=2
</code></pre>
<p>Would return the third through seventh Products in the Products entity set.</p>
<p>If no unique ordering is imposed through an <a href="#theorderbysystemqueryoption"><code>$orderby</code></a> query option, the service MUST impose a stable ordering across requests that include <code>$skip</code>.</p>
<h4 id="theinlinecountsystemqueryoption">10.2.3.6. The <code>$inlinecount</code> System Query Option</h4>
<p>The <code>$inlinecount</code> System Query Option with a value of <code>allpages</code> specifies that the total count of entities matching the request MUST be returned along with the result.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products?$inlinecount=allpages
</code></pre>
<p>Would return, along with the results, the total number of products in the set.</p>
<p>An <code>$inlinecount</code> query option with a value of <code>none</code> (or not specified) hints that the service SHOULD NOT return a count.</p>
<p>The service MUST return an HTTP Status code of <code>404 Bad Request</code> if a value other than <code>allpages</code> or <code>none</code> is specified.</p>
<p><code>$inlinecount</code> ignores any <a href="#thetopsystemqueryoption"><code>$top</code></a>, <a href="#theskipsystemqueryoption"><code>$skip</code></a>, or <a href="#theexpandsystemqueryoption"><code>$expand</code></a> query options, and returns the total count of results across all pages including only those results matching any specified <a href="#thefiltersystemqueryoption"><code>$filter</code></a>.</p>
<p>How the count is encoded in the response body is dependent upon the selected format.</p>
<h4 id="theformatsystemqueryoption">10.2.3.7. The <code>$format</code> System Query Option</h4>
<p>A request with a <code>$format</code> system query option specifies that the response SHOULD use the media type specified by the query option.</p>
<p>If the <code>$format</code> query option is present in a request, it SHOULD take precedence over the value(s) specified in the accept request header.</p>
<ul>
<li>If the value of the query option is “atom”, then the media type used in the response MUST be “application/atom+xml”, or “application/atomsvc+xml” for the <a href="#servicedocumentrequest">service document</a>.</li>
<li>If the value of the query option is “json”, then the media type used in the response MUST be “application/json”.</li>
<li>If the value of the query option is “xml”, then the media type used in the response MUST be “application/xml”.</li>
</ul>
<p>For example:</p>
<pre><code>http://host/service.svc/Orders?$format=json
</code></pre>
<p>Is equivalent to a request with the “accept” header set to “application/json”; it requests the set of Order entities represented using the JSON media type, as specified in <a href="../json-verbose-format">OData:JSON</a>.</p>
<p>The <code>$format</code> query option MAY be used in conjunction with <code>$value</code> to specify which raw format is returned.</p>
<pre><code>http://host/service.svc/Orders(1)/ShipCountry/$value/?$format=json
</code></pre>
<p>The raw value of the ShipCountry property of the matching Order using the JSON media type.</p>
<h3 id="requestinglinksbetweenentities">10.2.4. Requesting <code>$links</code> between Entities</h3>
<p>To request the links (URLs) of related entities according to a particular relationship, the client issues a GET request.</p>
<p>The path of the request is <code>/$links/</code> appended to the path of a the source entity’s request URL, followed by the name of the navigation property representing the relationship.</p>
<p>On success, the response body MUST contain the URL for each related entity, formatted as a either a single link, or a collection of links, depending on the cardinality of the relationship.</p>
<p>If the navigation property does not exist on the entity indicated by the request URL, the service SHOULD return <a href="#notfoundresponsecode"><code>404 Not Found</code></a>.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products(0)/$links/Orders
</code></pre>
<p>Returns the URLs of each Order related to the Product with <code>ID=0</code>.</p>
<h3 id="requestingthecountofanentitycollection">10.2.5. Requesting the <code>$count</code> of an Entity Collection</h3>
<p>To request only the count of an entity collection, the client issues a GET request with <code>/$count</code> appended to the path of the request URL.</p>
<p>On success, the response body MUST contain the count of entities matching the request, formatted as a simple scalar integer value.</p>
<p>For example:</p>
<pre><code>https://services.odata.org/OData/OData.svc/Products/$count
</code></pre>
<p>Returns the count of Products in the Products entity set.</p>
<h2 id="datamodification">10.3. Data Modification</h2>
<p>An OData service MAY support Create, Update, and Delete operations for some or all of the entities that it exposes. Additionally, services MAY support one or more <a href="#actions">Actions</a> which may affect the state of the system.</p>
<p>A successfully completed Data Modification request must not violate the integrity of the data.</p>
<p>A client may request whether content be returned from a Create, Update, or Delete request, or the invocation of an Action, by specifying the <a href="#thepreferheader"><code>Prefer</code> Header</a>.</p>
<h3 id="commondatamodificationsemantics">10.3.1. Common Data Modification Semantics</h3>
<p>Data modification requests share the following semantics.</p>
<h4 id="useofetagsforavoidingupdateconflicts">10.3.1.1 Use of ETags for Avoiding Update Conflicts</h4>
<p>A client MAY include an ETag value in a the <a href="#theif-matchrequestheader"><code>if-match</code></a> or the <a href="#theif-none-matchrequestheader"><code>if-none-match</code></a> request header of a Data Modification or <a href="#actions">Action</a> request. If specified, the operation MUST only be invoked if the <code>if-match</code> or <code>if-none-match</code> condition is satisfied.</p>
<p>The ETag value specified in the <code>if-match</code> or <code>if-none-match</code> request header may be obtained from an <a href="#theetagheader"><code>ETag</code> header</a> of a request for an individual entity, or may be included for an individual entry in a format-specific manner.</p>
<h4 id="differentialupdate">10.3.1.2. Differential Update</h4>
<p>Some update requests support two types of update: replace and merge. The client chooses which to execute by which HTTP verb it sends in the request.</p>
<p>A PUT request indicates a replacement update. The service MUST replace all property values with those specified in the request body. Missing properties MUST be set to their default values. Missing dynamic properties MUST be removed or set to NULL.</p>
<p>A PATCH or MERGE indicates a differential update. The service MUST replace exactly those property values that are specified in the request body. Missing properties, including dynamic properties, MUST NOT be altered.</p>
<p>The semantics of PATCH are defined in [RFC 5789][]. The service MUST be compliant with that definition.</p>
<p>The HTTP MERGE verb is defined by this document. The remainder of this section defines the semantics for the MERGE verb. All the semantics for HTTP PUT apply to HTTP MERGE. The only difference is client intent.</p>
<p>Because PATCH is a standard verb and MERGE is not, a client SHOULD prefer PATCH.</p>
<p>The semantics of a MERGE request on a data service entity is to merge the content in the request payload with the entity’s current state. The merging is done by comparing each component of the request body to the entity as it exists in the service.</p>
<p>If a component in the request body is not defined on the entity that is to be updated the request MAY be considered malformed.</p>
<p>If a component in the request body does match a component on the entity that is to be updated, the value of the component in the request body MUST replace the matching component of the entity to be updated and the matching process continues with the children of the component from the request body.</p>
<h3 id="createanentity">10.3.2. Create an Entity</h3>
<p>To create an entity in a collection, send a POST request to that collection’s URL. The POST body MUST contain a single valid entity representation.</p>
<p>To create an <em>open entity</em> (an instance of an open type), additional property values beyond those specified in the metadata MAY be sent in the request body. The service MUST treat these as dynamic properties and add them to the created instance.</p>
<p>If the entity being created is not an open entity, additional property values beyond those specified in the metadata SHOULD NOT be sent in the request body. The service SHOULD ignore any such values supplied.</p>
<p>Upon successful completion, the response MUST contain a <a href="#thelocationheader"><code>Location</code> header</a> that contains the edit URL of the created entity.</p>
<p>Upon successful completion the service MUST respond with either <a href="#createdresponsecode"><code>201 Created</code></a>, or <a href="#nocontentresponsecode">‘204 No Content’</a> if the request included a <a href="#thepreferheader"><code>Prefer</code></a> header with a value of "return-no-content’.</p>
<h4 id="linktorelatedentitieswhencreatinganentity">10.3.2.1. Link to Related Entities When Creating an Entity</h4>
<p>A service SHOULD support linking new entities to existing entities upon creation.</p>
<p>A request to create an entity MAY specify that the entity should be linked to existing entities. To bind the new entity to existing entities, include the required relationship link in the appropriate navigation property in the request body.</p>
<p>The representation for binding information is format specific.</p>
<p>On success, the service MUST create the requested entity and relate it to the requested existing entities.</p>
<p>On failure, the service MUST NOT create the new entity. In particular, the service MUST never create an entity in a partially-valid state (with the navigation property unset).</p>
<h4 id="createrelatedentitieswhencreatinganentity">10.3.2.2. Create Related Entities When Creating an Entity</h4>
<p>A service that supports creating entities SHOULD support creating related entities as part of the same request.</p>
<p>A request to create an entity MAY specify related entities that should also be created. The related entities MUST be represented using the appropriate inline representation of the navigation property.</p>
<p>On success, the service MUST create each entity and relate them.</p>
<p>On failure, the service MUST NOT create any of the entities.</p>
<h3 id="updateanentity">10.3.3. Update an Entity</h3>
<p>To update an existing entity, send a PUT, PATCH, or MERGE request to that entity’s edit URL. The request body MUST contain a single valid entity representation.</p>
<p>A service SHOULD support <a href="#differentialupdate">Differential Update</a> for entities.</p>
<p>If the request contains a value for a key property, the service MUST ignore that value when applying the update.</p>
<p>If the entity being updated is open, then additional values for properties beyond those specified in the metadata MAY be sent in the request body. The service MUST treat these as dynamic properties.</p>
<p>If the entity being updated is not open, then additional values for properties beyond those specified in the metadata SHOULD NOT be sent in the request body. The service SHOULD ignore any such values supplied.</p>
<p>On success, the response MUST be a valid <a href="#successresponsecodes">success response</a>.</p>
<h3 id="deleteanentity">10.3.4. Delete an Entity</h3>
<p>To delete an existing entity, send a DELETE request to that entity’s edit URL. The request body SHOULD be empty.</p>
<p>On success, the response MUST be <code>204 No Content</code>.</p>
<h3 id="modifyingrelationshipsbetweenentities">10.3.5. Modifying Relationships Between Entities</h3>
<p>Relationships between entities are represented by navigation properties as described in <a href="#datamodel">Data Model</a>. URL conventions for navigation properties are described in <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a>.</p>
<h4 id="createanewlinkbetweentwoexistingentitiesinaonetomanynavigationproperty">10.3.5.1. Create a New Link Between Two Existing Entities in a One to Many Navigation Property</h4>
<p>To relate an existing entity to another entity, send a POST request to the URL for the appropriate navigation property’s links collection. The request body MUST contain a URL that identifies the entity to be added.</p>
<p>The body MUST be formatted as a single link. See the appropriate format document for details.</p>
<p>On success, the response MUST be <code>204 No Content</code> and contain an empty body.</p>
<h4 id="removearelationshipbetweentwoentities">10.3.5.2. Remove a Relationship Between Two Entities</h4>
<p>To remove a relationship to a related entity, send a <code>DELETE</code> request to a URL that represents the link to the related entity.</p>
<p>The <code>DELETE</code> request MUST follow the requirements for integrity constraints above.</p>
<p>On success, the response MUST be <code>204 No Content</code> and contain an empty body.</p>
<h4 id="changetherelationinaonetoonenavigationproperty">10.3.5.3. Change the Relation in a One to One Navigation Property</h4>
<p>If a navigation property is nullable, then a change MAY be performed by first removing the existing relationship and then adding the new one. Use the approach described for adding and removing links.</p>
<p>Alternatively, a relationship MAY be updated as part of an update to the source entity by including the required binding information for the new target entity. This binding information MUST be formatted as for a deferred navigation property in a response.</p>
<h3 id="managingmediaentities">10.3.6 Managing Media Entities</h3>
<p>A <em>media entity</em> is an entity that represents an out-of-band stream, such as a photograph.</p>
<p>A media entity MUST have a <code>source url</code> that can be used to read the media stream, and MAY have an <code>edit-media</code> URL that can be used to write to the media stream.</p>
<p>Because a media entity has both a media stream and standard entity properties special handling is required.</p>
<h4 id="creatingamediaentity">10.3.6.1. Creating a Media Entity</h4>
<p>To create a media entity, send a POST request to the media entity’s entity set. The request body MUST contain the media value (for example, the photograph) in the appropriate media type.</p>
<p>On successful creation of the media, the service MUST respond with <code>201 Created</code> and a response body containing the newly created media entity.</p>
<h4 id="editingamediaentitystream">10.3.6.2. Editing a Media Entity Stream</h4>
<p>To change the data for a media entity stream, the client sends a PUT request to the edit URL of the media entity.</p>
<p>If the entity includes an ETag value, the client SHOULD include an <a href="#theif-matchrequestheader"><code>If-Match</code></a> header with the ETag value.</p>
<p>The request MUST contain a <a href="#thecontent-typeheader"><code>Content-Type</code></a> header, set to the correct value.</p>
<p>The body of the request MUST be the binary data that will be the new value for the stream.</p>
<h4 id="deletingamediaentity">10.3.6.3. Deleting a Media Entity</h4>
<p>To delete a media entity, send a DELETE request to the entity’s edit link as described in <a href="#deleteanentity">Delete An Entity</a>.</p>
<p>Deleting a media entity also deletes the media associated with the entity.</p>
<h3 id="managingnamedstreamproperties">10.3.7. Managing Named Stream Properties</h3>
<p>An entity may have one or <code>named stream properties</code>. Named stream properties are properties of type Edm.Stream.</p>
<p>The values for named stream properties do not appear in the entity payload. Instead, the values are read or written through URLs.</p>
<p>Named streams are not deletable or directly creatable by the client. The service owns their lifetime. The client can request to set the stream data to empty (0 bytes).</p>
<h4 id="editingnamedstreamvalues">10.3.7.1. Editing Named Stream Values</h4>
<p>To change the data for a named stream, the client sends a PUT request to the edit URL.</p>
<p>If the stream metadata includes an ETag value, the client SHOULD include an <a href="#theif-matchrequestheader"><code>If-Match</code></a> with the ETag value.</p>
<p>The request MUST contain a <a href="#thecontent-typeheader"><code>Content-Type</code></a> header, set to the correct value.</p>
<p>The body of the request MUST be the binary data that will be the new value for the stream.</p>
<h3 id="managingvaluesandpropertiesdirectly">10.3.8. Managing Values and Properties Directly</h3>
<p>Values and properties can be explicitly addressed with URLs. This allows them to be individually modified. See <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a> for details on addressing.</p>
<h4 id="updateaprimitiveproperty">10.3.8.1. Update a Primitive Property</h4>
<p>To update a value, the client MAY send a PUT, MERGE, or PATCH request to an edit URL for a primitive property. The message body MUST contain the new value, formatted as a single property according to the specified format.</p>
<p>Primitive properties do not support differential update. Regardless of which verb is used the service MUST replace the entire value with the value supplied in the request body.</p>
<p>The same rules apply whether this is a regular property or a dynamic property.</p>
<p>On success, the response MUST be a valid update <a href="#successresponsecodes">response</a>.</p>
<h4 id="nullavalue">10.3.8.2. Null a Value</h4>
<p>There are two ways to set a primitive value to NULL. The client MAY <a href="#updateaprimitiveproperty">Update a Primitive Property</a>, specifying a NULL value. Alternatively, the client MAY send a DELETE request with an empty message body to the property URL.</p>
<p>The service SHOULD consider a DELETE request to a non-nullable value to be malformed.</p>
<p>The same rules apply whether the target is the value of a regular property or the value of a dynamic property. A missing dynamic property is defined to be the same as a dynamic property with value NULL. All dynamic properties are nullable.</p>
<p>On success, the service MUST respond with <code>204 No Content</code> and an empty body.</p>
<h4 id="updateacomplextype">10.3.8.3. Update a Complex Type</h4>
<p>To update a complex type, send a PUT, PATCH, or MERGE request to that property’s URL. The request body MUST contain a single valid representation for that type.</p>
<p>A service MUST support <a href="#differentialupdate">Differential Update</a> for complex types.</p>
<p>On success, the response MUST be a valid update <a href="#successresponsecodes">response</a>.</p>
<h4 id="updateacollectionproperty">10.3.8.4. Update a Collection Property</h4>
<p>To update a value, send a PUT request to the collection property’s URL. The message body MUST contain the desired new value, formatted as a collection property according to the specified format.</p>
<p>The service MUST replace the entire value with the value supplied in the request body.</p>
<p>On success, the response MUST be a valid update <a href="#successresponsecodes">response</a>.</p>
<h2 id="operations">10.4. Operations</h2>
<p>Services MAY support custom operations. Operations (actions, functions and legacy service operations) are represented as function import elements in <a href="https://www.odata.org/documentation/odata-version-3-0/common-schema-definition-language-csdl">OData:CSDL</a>.</p>
<h3 id="commonrulesforalloperations">10.4.1 Common rules for all operations</h3>
<p>All operations MUST follow the rules outlined in <a href="https://www.odata.org/documentation/odata-version-3-0/common-schema-definition-language-csdl">OData:CSDL</a>.</p>
<h4 id="entitysetpathexpression">10.4.1.1. Entity Set Path Expression</h4>
<p>For functions or actions that return an entity or collection of entities, the entity set associated with the returned entity or collection of entities MAY depend upon the entity set of one of the parameter values used to invoke the operation.</p>
<p>When such a dependency exists an <em>entity set path expression</em> is used. An entity set path expression MUST begin with the name of a parameter to the operation, and optionally includes a series of navigation properties (and occasional type casts) as a succinct way to describe the series of entity set transitions.</p>
<p>The actual entity set transitions can be deduced by finding the association set backing each navigation property, and moving from the current entity set which will be found on one end to the entity set found on the other End.</p>
<p>The entity set of the results of an operation invocation with an entity set path expression can only be established once the entity set of the parameter that begins the entity set path expression is known.</p>
<p>For example this entity set path expression: “p1/Orders/Customer” can only be evaluated once the entity set of the p1 parameter value is known.</p>
<h4 id="commonrulesforbindingoperations">10.4.1.2. Common Rules for Binding Operations</h4>
<p>Actions and functions MAY be bound to an entity or a collection of entities. The first parameter of a bound operation is the <em>binding parameter</em>.</p>
<p>Any URL that can identify a binding parameter of the correct type MAY be used as the foundation of a URL to invoke an operation that supports binding using the resource identified by that URL as the <em>binding parameter value</em>.</p>
<p>For example, the function</p>
<pre><code>&lt;FunctionImport Name="MostRecentOrder" ReturnType="SampleModel.Order" EntitySet="Orders" IsBindable="true" IsSideEffecting="false" m:IsAlwaysBindable="true"&gt;
    &lt;Parameter Name="customer" Type="SampleModel.Customer" Mode="In" /&gt;
&lt;/FunctionImport&gt;`
</code></pre>
<p>can be bound to any url that identifies a <code>SampleModel.Customer</code>, two examples might be:</p>
<p><code>GET http://server/Customers(6)/MostRecentOrder()</code></p>
<p>Which invokes the <code>MostRecentOrder</code> function with the ‘customer’ or binding parameter value being the entity identified by http://server/Customers(6)/.</p>
<p><code>GET http://server/Contacts(23123)/Company/MostRecentOrder()</code></p>
<p>Which again invokes the <code>MostRecentOrder</code> function, this time with the ‘customer’ or binding parameter value being the entity identified by http://server/Contacts(23123)/Company/.</p>
<h3 id="actions">10.4.1. Actions</h3>
<p>Actions are operations exposed by an OData service that MAY have side effects when invoked. Actions MAY return data and are not composable.</p>
<h4 id="declaringactionsinmetadata">10.4.1.1. Declaring Actions in Metadata</h4>
<p>Actions SHOULD be declared in <code>$metadata</code> using a <code>FunctionImport</code> element that indicates the signature (name, return type and parameters) of the action.</p>
<p><a href="https://www.odata.org/documentation/odata-version-3-0/common-schema-definition-language-csdl">OData:CSDL</a> specifies how functions are syntactically defined in CSDL.</p>
<p>For example this <code>FunctionImport</code> represents an action that creates an order for a customer using the specified quantity and discount code. This action can be bound to any resource path that represents a <code>Customer</code> entity:</p>
<pre><code>&lt;FunctionImport Name="CreateOrder" IsBindable="true" IsSideEffecting="true" 
                metadata:IsAlwaysBindable="true"&gt;
    &lt;Parameter Name="customer" Type="SampleModel.Customer" Mode="In"&gt;
    &lt;Parameter Name="quantity" Type="Edm.Int32" Mode="In"&gt;
    &lt;Parameter Name="discountCode" Type="Edm.String" Mode="In"&gt;
&lt;/FunctionImport&gt;
</code></pre>
<h4 id="advertisingcurrentlyavailableactions">10.4.1.2. Advertising Currently Available Actions</h4>
<p><a href="https://www.odata.org/documentation/odata-version-3-0/atom-format">OData:Atom</a> and <a href="https://www.odata.org/documentation/odata-version-3-0/json-verbose-format">OData:JSON</a> formats require all actions that are available for the current entity or current collection of entities to be advertised inside any representation of the entity or collection entities returned from the service.</p>
<p>A service SHOULD advertise only those actions that are available for a given entity or collection of entities. The service MAY advertise all actions for a given entity or collection of entities. The service MAY fail later if the client attempts to invoke the action and it is found to be not available.</p>
<p>The following information MUST be included, as defined within the appropriate format, when an action is advertised:</p>
<ul>
<li>A ‘Target Url’ that MUST identify the resource that accepts requests to invoke the action.</li>
<li>A ‘Metadata Url’ that MUST identify the <code>FunctionImport</code> that declares the action. This URL can be either relative or absolute, but when relative it MUST be assumed to be relative to the <code>$metadata</code> URL of the current service.</li>
<li>A ‘Title’ that SHOULD contain a human readable description of the action.</li>
</ul>
<p>Example: Given a GET request to http://server/Customers(‘ALFKI’)</p>
<p>The service might respond with a Customer entity that advertises a binding of the <code>SampleEntities.CreateOrder</code> action to itself:</p>
<pre><code>{"d":
 { 
   "__metadata": { 
       ...,
       "actions" : {
           "SampleEntities.CreateOrder" : [{
               "title" : "Create Order",
               "target" : "Customers('ALFKI')/SampleEntities.CreateOrder"
           }]
       }
   },  
   "CustomerID": "ALFKI", 
   "CompanyName": "Alfreds Futterkiste", 
   ...
 }
}
</code></pre>
<p>When the resource retrieved represents a collection, the ‘Target Url’ of any actions advertised MUST encode every System Query Option used to retrieve the collection. In practice this means that any of these System Query Options should be encoded: $filter, $expand, $orderby, $skip and $top.</p>
<p>An efficient format that assumes client knowledge of metadata SHOULD NOT advertise Actions that are available on all instances and whose target url can be established via metadata.</p>
<h3 id="invokinganaction">10.4.1.3. Invoking an Action</h3>
<p>To invoke an action a client MUST make a POST request to the ‘Target Url’ of the action.</p>
<p>If the action supports binding the binding parameter value MUST be encoded in the ‘Target Url’. It is not possible to specify an entity or a collection of entities as a parameter value in the request body.</p>
<p>If the invoke request contains any non-binding parameter values, the <code>Content-Type</code> of the request MUST be <code>'application/json'</code>, and the parameter values MUST be encoded in a single JSON object in the request body.</p>
<p>Each non-binding parameter value specified MUST be encoded as a separate ‘name/value’ pair in a single JSON object that comprises the body of the request. The name is the name of the parameter. The value is the parameter value which is an instance of the type specified by the parameter in JSON format. Any parameter values not specified in the JSON object MUST be assumed to be null.</p>
<p>If the action returns results the client SHOULD use content type negotiation to request the results in the desired format, otherwise the default content type will be used.</p>
<p>If a client only wants an action to be processed when the binding parameter value, an entity or collection of entities, is unmodified, the client SHOULD include the <a href="#theif-matchrequestheader"><code>If-Match</code></a> header with the latest known ETag value for the entity or collection of entities.</p>
<p>On success, the response SHOULD be 200 for actions with a return type or 204 for action without a return type. The client can request whether any results from the action be returned using the <a href="#thepreferheader"><code>Prefer</code> header</a>.</p>
<p>Example: The following request invokes the <code>SampleEntities.CreateOrder</code> action using <code>/Customers('ALFKI')</code>as the customer (or binding parameter). The values <code>2</code> for the <code>quantity</code> parameter and <code>BLACKFRIDAY</code> for the <code>discountcode</code> parameter are passed in the body of the request:</p>
<pre><code>   POST http://server/Customers('ALFKI')/SampleEntities.CreateOrder
   {
      "quantity": 2,
      "discountCode": "BLACKFRIDAY"
   }
</code></pre>
<h4 id="actionoverloadresolution">10.4.1.4. Action Overload Resolution</h4>
<p>Actions support overloads, meaning a service MAY expose multiple actions with the same name that take a different set of parameters.</p>
<p>The combination of the action name, the binding parameter type and the unordered list of non-binding parameter names MUST be sufficient to uniquely identify a specific action overload.</p>
<h3 id="functions">10.4.2. Functions</h3>
<p>Functions are operations exposed by an OData service that MUST return data and MUST have no observable side effects.</p>
<h4 id="declaringfunctionsinmetadata">10.4.2.1. Declaring Functions in Metadata</h4>
<p>Functions SHOULD be declared in <code>$metadata</code>. Function declarations indicate the signature (Name, ReturnType and Parameters) and semantics (composability, bindability and result entity set) of the Function.</p>
<p><a href="https://www.odata.org/documentation/odata-version-3-0/common-schema-definition-language-csdl">OData:CSDL</a> specifies how functions are syntactically defined in CSDL.</p>
<p>For Example: The following <code>FunctionImport</code> describes a Function called MostRecent that returns the most recent Order within a collection of Orders:</p>
<pre><code>&lt;FunctionImport Name="MostRecent" EntitySet="Orders" ReturnType="SampleModel.Order" 
    IsBindable="true" IsSideEffecting="false" metadata:IsAlwaysBindable="true"&gt;
    &lt;Parameter Name="orders" Type="Collection(SampleModel.Order)" Mode="In"/&gt;
&lt;/FunctionImport&gt;
</code></pre>
<h4 id="advertisingcurrentlyavailablefunctionswithinapayload">10.4.2.2. Advertising Currently Available Functions within a Payload</h4>
<p>Functions MAY be bound to an entity or collection of entities. Services MAY choose whether to advertise functions within the entities or collections of entities returned from the Server.</p>
<p>Example: Given a GET request to <code>http://server//Orders</code>, the service might respond with a collection of Orders that advertises the <code>SampleEntities.MostRecent</code> Function bound to the collection:</p>
<pre><code>{
    "__metadata": {
        "functions": "SampleEntities.MostRecent" : [
            {
               "title" : "Most Recent Order",
               "target" : "Orders/SampleEntities.MostRecent"
            }
        ]
    },
    "d": [
         {
            "__metadata": { 
                            ...     
                          },
            "OrderID": 1,
            "ShippedDate": "/Date(872467200000)/",
            ...
         },
         ...
    ]
}
</code></pre>
<p>When the resource retrieved represents a collection, the ‘Target Url’ of any functions advertised MUST encode every System Query Option used to retrieve the collection. In practice this means that any of these System Query Options should be encoded: $filter, $expand, $orderby, $skip and $top.</p>
<p>An efficient format that assumes client knowledge of metadata SHOULD NOT advertise Functions that are available on all instances and whose target url can be established via metadata.</p>
<h4 id="invokingafunction">10.4.2.3. Invoking a Function</h4>
<p>To invoke a function directly a client MUST issue a GET request to a URL that identifies the function and that specifies any parameter values required by the function.</p>
<p>It is also possible to invoke a function indirectly using GET, PUT, POST, PATCH, MERGE or DELETE requests by formulating a URL that identifies a function and its parameters and then appending further path segments to create a request URL that identifies resources related to the results of the function.</p>
<p>Parameter values passed to functions MUST be specified either as a URL Literal (for Primitive Types) or as a JSON formatted OData object (for Complex Types or Collections of Primitive Types or Complex Types).</p>
<p>Functions calls MAY be present in the request URL path or the request URL query inside either the <a href="#thefiltersystemqueryoption"><code>$filter</code></a> or <a href="#theorderbysystemqueryoption"><code>$orderby</code></a> System Query Options.</p>
<h5 id="inlineparametersyntax">10.4.2.3.1. Inline Parameter Syntax</h5>
<p>The simplest way to pass parameter values to a function is using inline parameter syntax.</p>
<p>To use Inline Parameter Syntax, whereever a function is called, parameter values MUST be specified inside the parenthesis, i.e. <code>()</code>, appended directly to the function name.</p>
<p>The parameter values MUST be specified as a comma separated list of Name/Value pairs in the format <code>Name=Value</code>, where <code>Name</code> is the name of the parameter to the function and <code>Value</code> is the parameter value.</p>
<p>For example this request:</p>
<pre><code>GET http://server/Sales.GetEmployeesByManager(ManagerID=3)
</code></pre>
<p>Invokes a <code>Sales.GetEmployeesByManager</code> function which takes a single <code>ManagerID</code> parameter.</p>
<p>And this request:</p>
<pre><code>GET http://server/Customers?$filter=Sales.GetSalesRegion(City=$it/City) eq "Western"
</code></pre>
<p>Filters <code>Customers</code> to those in the <code>Western</code> sales region, calculated for each Customer in the collection by passing the Customer’s City as the <code>City</code> parameter value to the <code>Sales.GetSalesRegion</code> function.</p>
<p>Primitive parameters values may be provided to functions in the request URL path using inline syntax. All other parameter types MUST be provided externally.</p>
<h5 id="parameteraliases">10.4.2.3.2. Parameter Aliases</h5>
<p>Parameters MAY be specified by substituting a <code>parameter alias</code> in place of an inline parameter to a function call. Parameters aliases are names beginning with an ampersand (<code>@</code>).</p>
<p>Actual parameter values MUST be specified as query options in the query part of the request URL. The query option name is the Name of the parameter alias, and the query option value is the value to be used for the specified parameter alias.</p>
<p>For example:</p>
<pre><code>GET http://server/Sales.GetEmployeesByManager(ManagerID=@p1)?@p1=3
</code></pre>
<p>Parameter aliases allow the same parameter value to be used multiple times in a request and MAY be used to reference non-primitive values.</p>
<p>If a parameter alias referenced by a function call is not given a value in the Query part of the request URL, the value MUST be assumed to be <code>null</code>.</p>
<h5 id="parameternamesyntax">10.4.2.3.3. Parameter Name Syntax</h5>
<p>The OData protocol allows parameter values for the last Function call in a Request URL Path to be specified by appending Name/Value pairs, representing each parameter Name and Value for that Function, as query strings to the Query part of the Request URL.</p>
<p>This enables clients to invoke Functions without parsing the advertised Target Url.</p>
<p>For example:</p>
<pre><code>GET http://server/Sales.GetEmployeesByManager?ManagerID=3
</code></pre>
<h4 id="functionoverloadresolution">10.4.2.4. Function overload resolution</h4>
<p>Functions overloads are supported in OData, meaning a service MAY expose multiple Functions with the same name that take a different set of parameters.</p>
<p>When a function is invoked (using any of the three parameter syntaxes) the parameter names and parameter values are specified in the URL, and the parameter types can be deduced from each parameter value. The combination of the Function name and the unordered list of parameter types and names is always sufficient to identify a particular function overload.</p>
<hr />
<h1 id="appendixa:terminology">Appendix A: Terminology</h1>
<dl>
<dt>alias</dt>
<dd>A simple identifier that is typically used as a short name for a <strong>namespace</strong>.</dd>
<dt>alias qualified name</dt>
<dd>A qualified name that is used to refer to a <strong>structural type</strong>, except that the <strong>namespace</strong> is replaced by the alias for the <strong>namespace</strong>. For example, if an <strong>entity type</strong> called “Person” is defined in the “Model.Business” <strong>namespace</strong>, and that <strong>namespace</strong> has been given the <strong>alias</strong> “Self”, the alias qualified name for the person <strong>entity type</strong> is “Self.Person”.</dd>
<dt>annotation</dt>
<dd>Any custom, application-specific extension that is applied to an instance of <strong>CSDL</strong> through the use of custom attributes and elements that are not a part of this <strong>CSDL</strong> specification.</dd>
<dt>association</dt>
<dd>A named independent relationship between two <strong>entity type</strong> definitions. Associations in the <strong>Entity Data Model (EDM)</strong> are first-class concepts and are always bidirectional. Indeed, the first-class nature of associations helps distinguish the <strong>EDM</strong> from the relational model. Every association includes exactly two association ends.</dd>
<dt>association end</dt>
<dd>A term that specifies the <strong>entity type</strong> elements that are related, the roles of each of those <strong>entity type</strong> elements in the <strong>association</strong>, and the <strong>cardinality</strong> rules for each end of the <strong>association</strong>.</dd>
<dt>bound Action invocation URL</dt>
<dd>the URL that can be used to invoke a particular action bound to a particular entity or collection of entities.</dd>
<dt>bound Function invocation URL</dt>
<dd>the URL that can be used to invoke a particular function bound to a particular entity or collection of entities.</dd>
<dt>cardinality</dt>
<dd>The measure of the number of elements in a set.</dd>
<dt>collection</dt>
<dd>A grouping of one or more <strong>EDM types</strong> that are type compatible. A collection can be used as the return type for a <strong>FunctionImport</strong>.</dd>
<dt>conceptual schema definition language (CSDL)</dt>
<dd>A language that is based on XML and that can be used to define conceptual models that are based on the <strong>EDM</strong>.</dd>
<dt>conceptual schema definition language (CSDL) document</dt>
<dd>A document that contains a conceptual model that is described by using the <strong>CSDL</strong> code.</dd>
<dt>declared property</dt>
<dd>A property that is statically declared by a <strong>Property</strong> element as part of the definition of a <strong>structural type</strong>. For example, in the context of an <strong>entity type</strong>, a declared property includes all properties of an <strong>entity type</strong> that are represented by the <strong>Property</strong> child elements of the <strong>entity type</strong> element that defines the <strong>entity type</strong>.</dd>
<dt>derived type</dt>
<dd>A type that is derived from the <strong>base type</strong>. Only <strong>complex type</strong> and <strong>entity type</strong> can define a <strong>base type</strong>.</dd>
<dt>dynamic property</dt>
<dd>A designation for an instance of an <strong>open entity type</strong> that includes additional nullable properties (of a <strong>scalar type</strong> or <strong>complex type</strong>), or navigation properties, beyond its <strong>declared properties</strong>. The set of additional properties, and the type of each, may vary between instances of the same <strong>open entity type</strong>. Such additional properties are referred to as dynamic properties and do not have a representation in a <strong>CSDL document</strong>.</dd>
<dt>EDM type</dt>
<dd>A categorization that includes all the following types: <strong>EDMSimpleType</strong>, <strong>complex type</strong>, <strong>entity type</strong>, <strong>enumeration</strong>, and <strong>association</strong>.</dd>
<dt>entity</dt>
<dd>An instance of an <strong>entity type</strong> that has a unique identity and an independent existence. An entity is an operational unit of consistency.</dd>
<dt>entity request URL</dt>
<dd>A URL for requesting a single entity as a top-level object (as opposed to a collection containing a single entity). An entity request URL MAY be obtained from a response payload containing that instance (for example, as a self-link in an <a href="https://www.odata.org/media/30002/ODataAtomPayload">Atom Payload</a>). Services MAY support conventions for constructing an entity request URL using the entity’s Key Value(s), as described in <a href="https://www.odata.org/documentation/odata-version-3-0/url-conventions">OData:URL</a>.</dd>
<dt>Entity Data Model (EDM)</dt>
<dd>A set of concepts that describes the structure of data, regardless of its stored form, as described in the Introduction (section 1).</dd>
<dt>enumeration type</dt>
<dd>A type that represents a custom enumeration that is declared by using the <strong>EnumType</strong> element.</dd>
<dt>facet</dt>
<dd>An element that provides information that specializes the usage of a type. For example, the precision (that is, accuracy) facet can be used to define the precision of a <strong>DateTime property</strong>.</dd>
<dt>identifier</dt>
<dd>A string value that is used to uniquely identify a component of the <strong>CSDL</strong> and is of type <strong>SimpleIdentifier</strong>.</dd>
<dt>in scope</dt>
<dd>A designation that is applied to an XML construct that is visible or can be referenced, assuming that all other applicable rules are satisfied. Types that are in scope include all <strong>scalar types</strong> and <strong>structural type</strong> types that are defined in <strong>namespaces</strong> that are in scope. <strong>Namespaces</strong> that are in scope include the <strong>namespace</strong> of the current <strong>schema</strong> and other <strong>namespaces</strong> that are referenced in the current <strong>schema</strong> by using the <strong>Using</strong> element.</dd>
<dt>namespace</dt>
<dd>A name that is defined on the <strong>schema</strong> and that is subsequently used to prefix <strong>identifiers</strong> to form the <strong>namespace qualified name</strong> of a <strong>structural type</strong>. <strong>CSDL</strong> enforces a maximum length of 512 characters for namespace values.</dd>
<dt>namespace qualified name</dt>
<dd>A qualified name that refers to a <strong>structural type</strong> by using the name of the <strong>namespace</strong>, followed by a period, followed by the name of the <strong>structural type</strong>.</dd>
<dt>nominal type</dt>
<dd>A designation that applies to the types that can be referenced. Nominal types include all primitive types and named <strong>EDM types</strong>. Nominal types are frequently used inline with collection in the following format: collection(nominal_type).</dd>
<dt>property</dt>
<dd>An <strong>entity type</strong> can have one or more properties of the specified <strong>scalar type</strong> or <strong>complex type</strong>. A property can be a <strong>declared property</strong> or a <strong>dynamic property</strong>. (In <strong>CSDL 1.2</strong>, <strong>dynamic properties</strong> are defined only for use with <strong>open entity type</strong> instances.)</dd>
<dt>referential constraint</dt>
<dd>A constraint on the keys contained in the <strong>associatio</strong>n type. The ReferentialConstraint <strong>CSDL</strong> construct is used for defining referential constraints.</dd>
<dt>scalar type</dt>
<dd>A designation that applies to all <strong>EDMSimpleType</strong> and <strong>enumeration types</strong>. Scalar types do not include <strong>StructuralTypes</strong>.</dd>
<dt>schema</dt>
<dd>A container that defines a <strong>namespace</strong> that describes the scope of <strong>EDM types</strong>. All <strong>EDM types</strong> are contained within some <strong>namespace</strong>.</dd>
<dt>schema level named element</dt>
<dd>An element that is a child element of the <strong>schema</strong> and contains a <strong>Name</strong> attribute that must have a unique value.</dd>
<dt>structural type</dt>
<dd>A type that has members that define its structure. <strong>complex type</strong>, <strong>entity type</strong>, and <strong>association</strong> are all StructuralTypes.</dd>
<dt>type annotation</dt>
<dd>An <strong>annotation</strong> of a model element that allows a term and provision of zero or more values for the properties of the term.</dd>
<dt>type term</dt>
<dd>A structured term represented as an entity or complex type.</dd>
<dt>value annotation</dt>
<dd>An <strong>annotation</strong> that attaches a named value to a model element.</dd>
<dt>value term</dt>
<dd>A term with a single property in EDM.</dd>
<dt>vocabulary</dt>
<dd>A schema that contains definitions of value terms and/or type terms.</dd>
</dl>
